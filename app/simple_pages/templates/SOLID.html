{% extends "base.html" %}
{% block content %}
    <h1 class="underline">The concept of SOLID</h1>
    <h2>Introduction</h2>
    <div class="col-8">
        <p>
            SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also
            known
            as Uncle Bob).
        </p>
        <p>
            These principles establish practices that lend to developing software with considerations for maintaining
            and
            extending as the project grows. Adopting these practices can also contribute to avoiding code smells,
            refactoring code, and Agile or Adaptive software development.
        </p>
        <p>SOLID stands for:</p>
        <ul>
            <li>
                <a href="#S">
                    S - Single-responsibility Principle
                </a>
            </li>
            <li>
                <a href="#O">
                    O - Open-closed Principle
                </a>
            </li>
            <li>
                <a href="#L">
                    L - Liskov Substitution Principle
                </a>
            </li>
            <li>
                <a href="#I">
                    I - Interface Segregation Principle
                </a>
            </li>
            <li>
                <a href="#D">
                    D - Dependency Inversion Principle
                </a>
            </li>
        </ul>
    </div>


    <h2 id="S">Single-Responsibility Principle</h2>
    <div class="row">
        <div class="col-6">
            <p>
                Single-responsibility Principle states a class should have one and only one reason to change, meaning
                that a
                class should have only one job.
            </p>
        </div>
    </div>

    <div class="row">
        <div class="col-6">
            <p>
                For our calculator example, we have a class called Add, in Add class we only have one method which is to
                add two
                numbers and return the result.
            </p>
            <img src="{{ url_for('static', filename='images/code/add.png') }}" alt="" style="margin-bottom: 10px">
            <p>
                In our Subtract class, the only thing the class do is subtraction.
            </p>
            <img src="{{ url_for('static', filename='images/code/sub.png') }}" alt="">
            <p>
                Multiply class only do multiplication
            </p>
            <img src="{{ url_for('static', filename='images/code/mul.png') }}" alt="">
            <p>
                Divide is little tricky, since you need to handle a situation like divided by zero
            </p>
            <img src="{{ url_for('static', filename='images/code/divide.png') }}" alt="">
        </div>
    </div>
    <h2 id="O">Open-closed Principle</h2>
    <div class="col-7">
        <p>
            Open-closed Principle (OCP) states Objects or entities should be open for extension but closed for
            modification.
            Which means that a class should be extendable without modifying the class itself.
        </p>
    </div>

    <h2 id="L">Liskov Substitution Principle</h2>
    <div class="col-7">
        <p>
            Liskov Substitution Principle states let q(x) be a property provable about objects of x of type T. Then q(y)
            should be provable for objects y of type S where S is a subtype of T. This means that every subclass or
            derived
            class should be substitutable for their base or parent class.
        </p>
    </div>

    <h2 id="I">Interface Segregation Principle</h2>
    <div class="col-7">
        <p>
            Interface segregation principle states a client should never be forced to implement an interface that it
            doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.
        </p>
    </div>
    <h2 id="D">Dependency Inversion Principle</h2>
    <div class="col-7">
        <p>
            Dependency inversion principle states entities must depend on abstractions, not on concretions. It states
            that the high-level module must not depend on the low-level module, but they should depend on abstractions.
        </p>
    </div>
    <h2>Design pattern</h2>
    <div class="col-7">
        <p>
            Design patterns are typical solutions to commonly occurring problems in software design. They are like
            pre-made blueprints that you can customize to solve a recurring design problem in your code.
        </p>
        <p>
            This article covers three main groups of patterns: <br>
        <ul>
            <li>Creational patterns provide object creation mechanisms that increase flexibility and reuse of existing
                code.
            </li>
            <li>Structural patterns explain how to assemble objects and classes into larger structures, while keeping
                these structures flexible and efficient.
            </li>
            <li>Behavioral patterns take care of effective communication and the assignment of responsibilities between
                objects.
            </li>
        </ul>
        </p>
        <p>
            Here is an example of using factory method which is one of the method of creational design patterns in our calculator program:
        </p>
        <img src="{{ url_for('static', filename='images/code/factoryMethod.png') }}" alt="">
    <p>
        This code is to provides an interface for creating objects in superclass. <br>
        There are many other design patterns <a href="https://refactoring.guru/design-patterns/creational-patterns">click here</a> to know more detail.
    </p>
    </div>


{% endblock %}